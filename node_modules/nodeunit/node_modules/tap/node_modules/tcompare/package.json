{
  "name": "tcompare",
  "version": "2.2.0",
  "description": "A comprehensive comparison library, for use in test frameworks",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tapjs/tcompare.git"
  },
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "https://izs.me"
  },
  "license": "ISC",
  "files": [
    "index.js",
    "lib/*.js"
  ],
  "devDependencies": {
    "tap": "^13.0.0-rc.10"
  },
  "scripts": {
    "test": "tap --100",
    "snap": "tap --snapshot",
    "preversion": "npm test",
    "postversion": "npm publish",
    "postpublish": "git push origin --all; git push origin --tags"
  },
  "readme": "# tcompare\n\nA comprehensive comparison library, for use in test frameworks.  Walks an\nobject once, generating both a simple true/false result, as well as a\nnicely formatted human-readable diff string.\n\n## USAGE\n\n```js\nconst { match, same, strict, has, hasStrict, format } = require('tcompare')\n\n// Result is an object with { Boolean match, String diff }\nconst result = match(object, pattern)\nif (!result.match) {\n  console.log(`item did not match pattern`)\n  console.log(result.diff)\n} else {\n  console.log(`it's a match!`)\n}\n```\n\n## METHODS\n\n* `format(object, [options])` - No comparisons performed.  Just print out the\n  object.  Returns just the string format.\n* `same(object, pattern, [options])` - Ensure that all items in the pattern are\n  found in the object, and vice versa, matching loosely (so, for example `1`\n  will match with `'1'`).\n* `strict(object, pattern, [options])` - Ensure that all items in the pattern\n  are found in the object, and vice versa, matching strictly (so, for example\n  `1` will not match with `'1'`).\n* `has(object, pattern, [options])` - Ensure that all items in the pattern are\n  found in the object, but ignore additional items found in the object,\n  matching loosely.\n* `hasStrict(object, pattern, [options])` - Ensure that all items in the\n  pattern are found in the object, but ignore additional items found in the\n  object, matching strictly.\n* `match(object, pattern, [options])` - Verify that all items in `pattern` are\n  found in `object`, and that they match.  This is the loosest possible\n  algorithm, allowing cases where we just want to verify that an object\n  contains a few important properties.  The algorithm is the same as\n  the one used by [tmatch](http://npm.im/tmatch).  In a nutshell:\n    * If the object and pattern are loosely equal, then pass\n    * If the object and the pattern are both Regular Expressions, Date objects\n      or Buffers, then pass if they're \"equivalent\".\n    * If the pattern is a RegExp, cast object to a string, and test against the\n      RegExp.\n    * If both are Strings, pass if pattern appears in object.\n    * If pattern is a function, and object is an instance of that function,\n      then pass.  (This also applies to Symbol, Number, String, etc.)\n    * If pattern and object are collections (object, map, set, array or\n      iterable), then compare their contents.  Each type of collection can only\n      match its same type, with the exception of non-Set iterables (including\n      `arguments` objects), which are cast to Arrays.\n\nThere are classes exported to correspond to each of these.  All of these are\ninstantiated like `new Format(object, options)`.  An `expect` option is\nrequired for all classes except `Format`.  Call `obj.print()` on the resulting\nobject to generate a diff.  Once the diff (or format) is generated, it'll have\na `match` boolean member.\n\n## OPTIONS\n\nEach method can take the following options.\n\n* `style` - Set to `pretty` for a very human-readable style of object printing.\n  Set to `js` for a copy-and-paste friendly valid JavaScript output.  Set to\n  `tight` for a minimal white-space js format.  Default is `pretty`.  Example:\n\n    ```\n    // pretty style\n    Object {\n      \"myMap\": Map {\n        Object {\n          \"a\": 1,\n        } => Object {\n          \"b\": 2,\n        }\n      }\n    }\n\n    // js style\n    {\n      \"myMap\": new Map([\n        [{\n          \"a\": 1,\n        }, {\n          \"b\": 2,\n        }]\n      ])\n    }\n\n    // tight style\n    {\"myMap\":new Map([[{\"a\":1,},{\"b\":2,}],]),}\n    ```\n\n    Note that `tight` is not suitable for comparisons, only formatting.\n\n## Circular References\n\nCircular references are displayed using YAML-like references, so it's easy to\ndetermine _which_ item is circularly referenced.\n\nWhen doing comparisons, a pattern and object will be considered matching if\nthey contain the _same_ circularity.  So, for example, if a pattern refers to\nitself, then an object should refer to itself as well.\n\n```js\nconst a = {list: [], b: {}}\na.list.push(a)\na.list.push(a.b)\na.b.a = a\nconsole.log(format(a))\n\n/*\n&ref_1 Object {\n  \"list\": Array [\n    <*ref_1>,\n    Object {\n      \"a\": <*ref_1>,\n    },\n  ],\n  \"b\": Object {\n    \"a\": <*ref_1>,\n  },\n}\n*/\n```\n\nNote that circular references are never going to be valid JavaScript, even when\nusing the `js` style.\n",
  "readmeFilename": "README.md",
  "_id": "tcompare@2.2.0",
  "_from": "tcompare@^2.2.0"
}
