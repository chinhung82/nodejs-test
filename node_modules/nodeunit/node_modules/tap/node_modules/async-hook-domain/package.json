{
  "name": "async-hook-domain",
  "version": "1.1.0",
  "description": "An implementation of Domain-like error handling, built on async_hooks",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "source-map-support": "^0.5.11"
  },
  "devDependencies": {
    "tap": "^13.0.0-rc.11"
  },
  "scripts": {
    "test": "tap test/run.js",
    "snap": "tap test/run.js",
    "preversion": "npm test",
    "postversion": "npm publish",
    "postpublish": "git push origin --all; git push origin --tags"
  },
  "tap": {
    "check-coverage": true
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/async-hook-domain.git"
  },
  "keywords": [
    "async",
    "hooks",
    "async_hooks",
    "domain",
    "error",
    "handling",
    "handler",
    "uncaughtException",
    "unhandledRejection",
    "catch",
    "promise",
    "execution",
    "context"
  ],
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "https://blog.izs.me"
  },
  "license": "ISC",
  "files": [
    "index.js"
  ],
  "readme": "# async-hook-domain\n\nAn implementation of the error-handling properties of the (deprecated) `domain`\nnode core module, re-implemented on top of\n[`async_hooks`](https://nodejs.org/api/async_hooks.html).\n\n## USAGE\n\n```js\nconst Domain = require('async-hook-domain')\n\n// instantiating a Domain attaches it to the current async execution\n// context, and all child contexts that come off of it.  You don't have\n// to call d.enter() or d.run(cb), just instantiate and it's done.\n// Pass an error-handling function to the constructor.  This function\n// will be called whenever there is an uncaught exception or an\n// unhandled Promise rejection.\n\nconst d = new Domain(er => {\n  console.log('caught an error', er)\n  // if you re-throw, it's not going to be caught, and will probably\n  // cause the process to crash.\n})\n\nsetTimeout(() => {\n  throw new Error('this is caught by the domain a few lines up')\n})\n\nprocess.nextTick(() => {\n  const d2 = new Domain(er => {\n    console.log('any contexts spawned from this nextTick are caught here', er)\n    // only catch one error.  The next one will go to the parent\n    d2.destroy()\n  })\n  fs.readFile('does not exist', (er, data) => {\n    if (er)\n      throw er\n  })\n  fs.readFile('also does not exist', (er, data) => {\n    if (er)\n      throw er\n  })\n})\n\n// Adding a new domain here in the same context as the d above will\n// take over for this current context, as well as any that are created\n// from now on.  But it won't affect the setTimeout above, because that\n// async context was created before this domain existed.\nconst d3 = new Domain(er => console.log('d3', er))\n\n// Unhandled promise rejections are handled, too.\nPromise.reject(new Error('this will be handled by d3'))\n\n// since a Promise rejection is an async hop, if we destroyed it right\n// now, it would not be there to catch the Promise.reject event.\nsetTimeout(() => {\n  // destroying d3 makes it like it never happened, so this will\n  // be handled by the parent domain we created at the outset.\n  d3.destroy()\n  throw new Error('this will be handled by the parent')\n})\n\n// When all domains are destroyed either manually or by virtue of their\n// async execution contexts being completed, or if no domain is active\n// for the current execution context, then it reverts back to normal\n// operation, with all event handlers removed and everything cleaned up.\nsetTimeout(() => {\n  d.destroy()\n  throw new Error('this crashes the process like normal')\n}, 500) // time for the other contexts to wrap up\n```\n\nIf you want to limit a Domain to a narrower scope, you can use node's\n[`AsyncResource`](https://nodejs.org/api/async_hooks.html#async_hooks_class_asyncresource)\nclass, and instantiate the domain within its `runInAsyncScope(cb)` method.\nFrom then on, the domain will only be active when running from that Async\nResource's scope.\n\n## API\n\n### `process.env.ASYNC_HOOK_DOMAIN_DEBUG = '1'`\n\nSet the `ASYNC_HOOK_DOMAIN_DEBUG` environment variable to `'1'` to print a lot\nof debugging information to stderr.\n\n### const d = new Domain(errorHandlerFunction(error, type))\n\nCreate a new Domain and assign it to the current execution context and all\nchild contexts that the current one triggers.\n\nThe handler function is called with two arguments.  The first is the error that\nwas thrown or the rejection value of the rejected Promise.  The second is\neither `'uncaughtException'` or `'unhandledRejection'`, depending on the type\nof event that raised the error.\n\n### d.parent Domain\n\nIf a Domain is already assigned to the current context on creation, then the\ncurrent Domain set as the new Domain's `parent`.  On destruction, any of a\nDomain's still-active execution contexts are assigned to its parent.\n\n### d.onerror Function\n\nThe `errorHandlerFunction` passed into the constructor.  Called when an\nuncaughtException or unhandledRejection occurs in the scope of the Domain.\n\nIf this function throws, then the domain will be destroyed, and the thrown\nerror will be raised.  If the domain doesn't have a parent, then this will\nlikely crash the process entirely.\n\n### d.destroyed Boolean\n\nSet to `true` if the domain is destroyed.\n\n### d.ids Set\n\nA set of the `executionAsyncId` values corresponding to the execution contexts\nfor which this Domain handles errors.\n\n### d.destroy() Function\n\nCall to destroy the domain.  This removes it from the system entirely,\nassigning any outstanding ids to its parent, if it has one, or leaving them\nuncovered if not.\n\nThis is called implicitly when the domain's last covered execution context is\ndestroyed, since at that point, the domain is unreachable anyway.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/isaacs/async-hook-domain/issues"
  },
  "_id": "async-hook-domain@1.1.0",
  "_from": "async-hook-domain@^1.1.0"
}
