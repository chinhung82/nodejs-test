{
  "name": "istanbul-lib-processinfo",
  "version": "1.0.0",
  "description": "A utility for managing the `processinfo` folder that NYC uses.",
  "main": "index.js",
  "scripts": {
    "test": "tap -j1",
    "snap": "tap -j1",
    "preversion": "npm test",
    "postversion": "npm publish",
    "postpublish": "git push origin --all; git push origin --tags"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/istanbuljs/istanbul-lib-processinfo.git"
  },
  "license": "ISC",
  "dependencies": {
    "archy": "^1.0.0",
    "cross-spawn": "^6.0.5",
    "istanbul-lib-coverage": "^2.0.3",
    "rimraf": "^2.6.3",
    "uuid": "^3.3.2"
  },
  "devDependencies": {
    "nyc": "^14.0.0-rc.1",
    "tap": "^13.0.0-rc.23"
  },
  "tap": {
    "check-coverage": true
  },
  "files": [
    "index.js"
  ],
  "nyc": {
    "include": "index.js"
  },
  "readme": "# istanbul-lib-processinfo\n\nA utility for managing the `processinfo` folder that NYC uses.\n\nThis is intended to be used along with [NYC](https://npm.im/nyc), but can also\nbe used by other tools that wish to consume NYC's processinfo data.\n\n## API\n\n### class ProcessInfo\n\nA representation of information about a single process.\n\n#### constructor(fields)\n\nPass in fields that will be printed to the processinfo file.  Several defaults\nwill be provided if not specified.\n\n#### processInfo.save()\n\nWrite this process info to disk.  This works by passing the ProcessInfo object\nto JSON.stringify, and writing to `${nyc temp dir}/processinfo/${uuid}.json`.\n\n#### processInfo.getCoverageMap(nyc)\n\nGet a merged coverage map of the current process, as well as any child\nprocesses.  This should only be called during tree rendering, as it depends on\nchild nodes being present in the `nodes` array.\n\nThe `nyc` instance is required to load the report information and apply\nsourcemaps properly.\n\n### processInfo.label\n\nA read-only string for when archy prints the process tree.\n\n### processInfo.nodes\n\nA list of the child nodes used during tree rendering.\n\n### processInfo.processInfoDirectory\n\nIf a process will be saved, it ought to have a `processInfoDirectory` included\nin the list of fields.  The default is `${cwd}/.nyc_output/processinfo`.  This\nproperty is not saved to the processinfo file.\n\n## class ProcessDB\n\nA utility for interacting with the collection of ProcessInfo files in the\nprocessinfo folder.\n\n### constructor(dir)\n\nSupply the directory where processinfo files are found.  This should be the\nfull path, something like `${cwd}/.nyc_output/processinfo`.\n\n### processDB.dir\n\nA read-only property showing the directory where this object is working.\n\n### processDB.nodes\n\nA list of child ProcessInfo nodes used in tree printing.\n\n### processDB.label\n\nThe string `'nyc'`, used as the default root node in the archy tree rendering.\n\n### processDB.writeIndex()\n\nCreate the `index.json` file in the processinfo folder, which is required for\ntree generation and expunging.\n\nWARNING: Index writing is non-atomic, and should not be performed by multiple \n\n### processDB.readIndex()\n\nRead and return the contents of the `index.json` file.  If the `index.json` is\nnot present or not valid, then it will attempt to generate one.\n\n### processDB.readProcessInfos()\n\nRead all the data files in the processinfo folder, and return an object mapping\nthe file basename to the resulting object.  Used in tree generation.\n\n### processDB.renderTree(nyc)\n\nRender the tree as a string using archy, suitable for printing to the terminal.\n\n### processDB.buildProcessTree()\n\nBuild the hierarchical tree of nodes for tree rendering.  Populates the `nodes`\narray of this object and all `ProcessInfo` objects in the tree.\n\n### processDB.getCoverageMap(nyc)\n\nUsed in tree rendering, to show the total coverage of all the processinfo files\nin the data folder.\n\n### processDB.spawn(name, file, args, options)\n\nSpawn a child process with a unique name provided by the caller.  This name is\nstored as the `externalId` property in the child process's `ProcessInfo` data,\nand is tracked in the `externalIds` section of the index.\n\nNote that if the current process is not already wrapped by nyc, then you must\nprefix the spawned program with nyc, in order for this to take effect.  For\nexample, instead of `processDB.spawn('foo', 'node', ['foo.js'])`, you would run\n`processDB.spawn('foo', 'nyc', ['node', 'foo.js'])`.\n\nIf a process with that name already exists in the index, then it will be\nexpunged.\n\nIf `options.regenerateIndex` is `true`, then ProcessDB will re-write the index\nwhen the process is completed.\n\nWARNING: Calling `expunge` (which this method does) will result in the index\nbeing out of date.  It is the caller's responsibility to call\n`processDB.writeIndex()` when all named processes are completed.\n\n### processDB.spawnSync(name, file, args, options)\n\nSync form of `processDB.spawn()`.\n\n### processDB.expunge(name)\n\nIf a process exists in the process info data folder with the specified name\n(ie, it had previously been run with `processDB.spawn(name, ...)`) then the\ncoverage and processinfo files for it and all of its children are removed.\n\nThis allows for a test harness to re-run or resume test suites, without\nspurious coverage results.\n\nWARNING: Calling `expunge` will result in the index being out of date.  It is\nthe caller's responsibility to call `processDB.writeIndex()` when all named\nprocesses are completed.\n\n## DATA STRUCTURES and FILES\n\nProcessInfo files MUST match the following structure:\n\n```\n{\n  \"uuid\": \"UUID of the process itself\",\n  \"parent\": \"UUID of the parent process, or null\",\n  \"pid\": Number,\n  \"ppid\": Number (pid of parent process),\n  \"argv\": Array<String>,\n  \"execArgv\": Array<String>,\n  \"cwd\": path,\n  \"time\": Number (timestamp in ms),\n  \"root\": \"UUID of NYC process group\",\n  \"coverageFilename\": \"Path to NYC coverage info for this process\",\n  \"externalId\": \"The externally specified name for this process, or null\",\n}\n```\n\nEach file is saved to `${nyc temp dir}/processinfo/${uuid}.json`.\n\nThe index file is saved to `${nyc temp dir}/processinfo/index.json`.  It has\nthe following structure:\n\n```\n{\n  \"processes\": {\n    \"<uuid>\": {\n      \"parent\": \"parent uuid, or null\",\n      \"children\": [\"children\", \"uuids\", \"or empty array\"],\n      \"externalId\": \"externally specified name, if provided\"\n    },\n    ...\n  },\n  \"files\": {\n    \"/path/to/covered/file.js\": [\n      \"<uuids of processes that covered this file>\",\n      ...\n    ],\n    ...\n  },\n  \"externalIds\": {\n    \"externally specified name\": {\n      \"root\": \"<uuid of process run under this name>\",\n      \"children\": [\n        \"<uuids of all descendant processes from this point in the tree>\",\n        ...\n      ]\n    },\n    ...\n  }\n}\n```\n",
  "readmeFilename": "README.md",
  "_id": "istanbul-lib-processinfo@1.0.0",
  "_from": "istanbul-lib-processinfo@^1.0.0"
}
